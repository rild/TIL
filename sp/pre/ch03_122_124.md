# The running time of programs

## Climbing the Structure Tree to Determine Running Time
基底と再帰
**基底, BASIS**
ある単純な命題について
- 代入, Read Write, ジャンプの実行時間は O(1) である

**再帰, INDUCTION**
- すでに議論した５つの要素からなるものについて
  - その実行時間は次のように表される

### ５つの要素について 3 ~ 5
#### 3

*statement*

命題において

- プログラム本体 (body) の実行時間の上限が O(f(n)) である
  - an upper bound on the running time
- g(n) がループ回数の上限である
  - the number of times around the loop

この２つの条件を満たす場合

命題の時間 the time の上限は,
O(1 + (f(n) + 1)g(n)) となる.

係数 (the factor) f(n) + 1 は,
- 1回あたりのコスト (計算コスト？) を表している
  - (including)
  - the body, the test, and the reinitialization
  - 本体, テスト, 再初期化

1+ の部分が表すもの
- 最初の初期化と, 初期のテストが実行されない (negative) 可能性を表す
  - ループが起こらない場合を表す

f(n) と g(n) について一般的に言えること
- 少なくとも 1 以上の値をとる
- 1 以上の値で再定義され得る
 - 実行時間は O(f(n)g(n)) となる
- 以上は Fig.3.13 の (c) で表されている

<img src="https://gyazo.com/e8b66317da435dd801e06a9cfc061103.png" />

#### 4

*selection statement*

もし, O(f_1(n)) と O(f_2(n)) が if 構文と, else 構文の実行時間の上限であるとするなら,
- 選択命題 (selection statement) の実行時間の上限
  - O(1 + max(f_1(n), f_2(n)))

1+ の部分は, テストを表す
- 一般的に, f_1(n) や f_2(n) の一部は, 少なくとも全ての n に対して正 (positive) となる
  - 1+ は省略されることもある
  - can be omitted

さらに,

もし, f_1(n) や f_2(n) の一部が他の部分の O 記法 となる場合,
- 表現を単純化することができる
  - どちらであってもより大きい
  - Ex 3.5.5 で言及した
- Fig. 3.14. では, if　文の計算時間 (computation of running time) が示してある

<img src="https://gyazo.com/32a9b8e4325cf1b389a25c9772e335be.png" />

#### 5

*Block*
ｶﾀﾏﾘ？

もし, O(f_1(n)), O(f_2(n)), ..., O(f_k(n)) がそのブロックについての命題の上限であるならば,
- O(f_1(n) + f_2(n) + ... + f_k(n)) がそのブロックの (実行時間の) 上限となる
- 可能であるなら, より単純な別の表現を使用するべき (総和規則, the summation rule)
  - 規則は Fig. 3.15 に図示する

<img src="https://gyazo.com/7c602124a80013657ed352ae70786d94.png" />

### まとめ
以上の５つの規則を構造木 (the structure tree) に対して適用する

構造木
- より小さな命題を複数まとめた構造をしている

言い換えると,
これらの規則の適用は,
- 全て単純な命題から始められる
  - 単純な命題 (the simple statements) は基底によってカバーされている
  - 徐々に大きくなり続ける複雑な命題にも, 再帰を適用することができる
  - ５つの再帰のどれであっても同様

しかしながら,

実行時間の上限は考えることができるが,
プログラムを構成する全ての部分 (命題) について分析したあとでのみ, 複雑な命題の実行時間を解析することができる.

## 例題
Example 3.21.
Fig. 3.11 で紹介した選択ソートのプログラムを再度確認していく.

<img src="https://gyazo.com/06b10e8fe1083fc1c28bc2c3db7006d6.png" />

構造木 (structure tree) は Fig. 3.12 で示した.

<img src="https://gyazo.com/7805b99e5fa03445c0950e77bc2c768f.ong" />

### 葉に注目
はじめに,
- それぞれの代入処理 (the assignment statements) は Fig. 3.12 で葉として表現してある.
  - 葉のオーダーは O(1) 時間

### 一つ上
構造木を上に見ていくと, プログラムの中で (4), (5) の部分を示す, if 文の構文が現れる.
- 例題 3.15 を思い出す
  - オーダーは O(1) であった

引き続き, 木を上に見ていく
- より小さな構文からそれらを含むより大きな構文へ

(3) ~ (5) の for 文について
- 例題 3.14 と同様
  - 実行時間のオーダーは O(n-i-1)
- 実行時間を二つの変数 n, i から成る一つの関数として実行時間を表現してきた
  - 計算が複雑になる
  - 代わりに, 緩やかな上限としての O(n)
- O(n-i-1) を上限とした場合
  - Fig. 3.11 の (1) から観察しなければならなくなる
  - このとき, i は n-1 より小さい点に注意する

n-i-1 は確実に, 0 より大きく, O(1) に寄与する (dominates O(1))
- O(n-i-1) に対して O(1) の部分を加える必要がなくなる
  - 注目する for 文の j を初期化する際について

### 二つ上
さらに木を遡る
(2) ~ (8) のブロックについての構文
- 例題 3.17 と同様
  - ブロックの実行時間は, ４種類の O(1) の合計

関連する項目
- ４つの代入構文
- (3) ~ (5) の複数の構文について O(n-i-1) を加える

総和の規則によると,
i < n での観測を加え, O(1) を落とし, ブロックの実行時間として, O(n-i-1) が残る

### 最後
最後に, (1) ~ (8) の for 文について考える

このループは 3 章 6 節では議論されていない.

しかし, `(3) の規則`を適用することができる.

```math
命題において

- プログラム本体 (body) の実行時間の上限が O(f(n)) である
  - an upper bound on the running time
- g(n) がループ回数の上限である
  - the number of times around the loop

この２つの条件を満たす場合

命題の時間 the time の上限は,
O(1 + (f(n) + 1)g(n)) となる.
```

ルールでは, プログラム本体 (body) の実行時間の上限を必要とした.
- 今回は, (2) ~ (8) に当たる
  - 該当する部分の実行時間の上限を O(n-i-1) とする

このとき, これまで考えたことがない状態になる.

ブロックに対して, i が定数である一方で,
外側の for 文では, i は index (つまり変数) となっている.
- i はループごとに値が異なる

したがって, O(n-i-1) の上限が意味をなさない.
- それをループの全ての繰り返しに関する実行時間として考える場合において

幸運にも,
- (1) 行目から, i は決して 0 を下回ることがない
ということはわかる
これにより,
- O(n-1) が O(n-i-1) の上限である
ということがわかる.

さらに, より小さなオーダー (low-order term) は問題にならない規則を適用することで,
- O(n-1) は O(n)
として単純化することができる.

### 実行回数
次に, ループの回数を決定する必要がある.

i は 0 から n-2 までの値をとる.
- n-1 回のループを行う
