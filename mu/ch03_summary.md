Chapter 3 のまとめ

- プログラムにとって, 多くの要素はアルゴリズムの選択となる. しかし, （プログラムの）単純化や, 実装の容易さ, プログラムの効率が支配的になる場合もある.
- *O* 記法は, プログラムの実行時間 (the running times of programs) の便利な指標となる.
- C 言語で記述された様々なプログラムの実行時間の評価には, 再帰的な規則が存在する. for 文や, 条件比較といった, プログラムを構成する要素の実行時間の観点による.
- 再帰的な関係性 (recurrence relations) を用いることは再帰プログラムの実行時間をモデル化する上で自然な手法である.
- 再帰関係の問題を解くために, 繰り返しの置換または, 解法の推測とその妥当性の確認のいずれかが用いられる.

ある問題がそれを構成するより小さな単位に分け, その小さな単位への解法を与えられる時, 分割と統合がアルゴリズムデザインについての大切な技術となる. 小さな解法を組み合わせることによって全体の問題への解法とする.

少しの親指の規則 (rules of thumb) がアルゴリズムの解となる実行時間を評価することに使うことができる.
自身の実行オーダーが *O(1)* で, 副問題として, 再帰呼び出しを *n-1* の大きさで行なっているような関数の実行オーダーは *O(n)* である. 具体的には, *fact* 関数や, *merge* 関数.

- より一般的には, 実行オーダーが *O(n^k)* で, 大きさ *n-1* の副問題として再帰呼び出しを行う関数の実行オーダーは *O(n^(k+1))* である.

- もし, 関数が再帰呼び出しを２回行なっていながらも, その再帰は (マージソートで行われているような) *log_2(n)* レベルで行われる場合, 全体の実行時間はそれぞれの呼び出しでの処理で *O(nlog(n))* の実行オーダーとなる. 加えて, 基底として *O(n)* が加えられる.
  - マージソートの例では基底の呼び出しを含むそれぞれの呼び出しでの処理は実行オーダーが *O(1)* である. そのため, 全体の実行オーダーは *O(nlog(n)) + O(n)*, または単に *O(nlog(n))* と表される.

- もし, 関数が再帰呼び出しを２回行なっていながらも, その再帰は (フィボナッチ数列のプログラム, Ex 3.9.4., で行われているような) *n* レベルで行われる場合, その実行時間は *n* の指数関数状になる. 
